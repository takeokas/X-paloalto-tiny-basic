# X-paloalto-tiny-basic
## 拡張 PaloAlto Tiny BASIC インタープリタ
  オリジナルはPalo Alto Tiny BASIC  
  8080用ソースコード。(INP,OUTのみZ80命令を使用)    
  スーパーAKI80用。xbasaki.hex をROMに焼けば動作する。  
  オリジナルの Dr.Wang の Palo Alto Tiny BASICは、
  <a href="https://www.icl1900.co.uk/unix4fun/z80pack/ftp/altair/DrDobbs-1976-05-v1n5.pdf" target="_blank"> Dr.Dobb's Journal 1976/MAY の P.12 に掲載</a>  
   
# xbasaki.hex は秋月 スーパーAKI80 用のバイナリで、そのままROMに焼けば動く。  

### ステートメントの区切り記号は「:」に変更。
 (オリジナルは「;」。「:」はMircosoft BASICにならった)  
### 行エディタを付加  
  「EDIT 行番号」で指定した行を、編集可能  
  <- ^A  <^B  DEL^D  ^F> ^E->  
### 入力行ヒストリ
   ^Pで、一つ前の入力行を呼び出せる。ヒストリは1つのみ    
### 二項演算子を拡張
  | :OR,  &: AND, ^: XOR  
  式1 << 式2 : 式1の値を 式2のビットだけ左シフト。  
  式1 >> 式2 : 式1の値を 式2のビットだけ右シフト。  
### PEEK, POKE, CALL を拡張
  PEEK(アドレス) :関数。アドレスで指定されたメモリから1バイト読む。  
  POKE アドレス,値 :ステートメント。アドレスで指定されたメモリに値を1バイト書き込む。  
  CALL アドレス : アドレスで指定されたメモリの機械語サブルーチンをコールする。  
### INP, OUTを拡張  
  INP(INアドレス): 関数。INアドレスで指定された入力ポートから1バイト読む。  
  OUT OUTアドレス,値 :ステートメント。OUTアドレスで指定された出力ポートに値を1バイト書き込む。  
### 十六進定数  
  $から始まる十六進定数を扱える  
  「&H」ではなく「$」。  
### 十六進プリント・ステートメント
  ?? 式: 式の値を十六進4桁でプリント。  
  ?$ 式: 式の値を十六進2桁でプリント。  
### 十進プリント・ステートメントの追加
  ?: 「PRINT」文と同様

### 一文字入力
  無引数関数 「$」 : キーボードからの1文字入力。  
### テキスト先頭アドレス変数, テキスト末尾アドレス変数
  「[」 : プログラム・テキストの先頭アドレスを保持する変数。代入可能。代入後に「==」を実行する。  
  「]」 : プログラム・テキストの末尾アドレスを保持する変数。  
###   テキスト末尾サーチ・ステートメント
  「==」: テキスト末尾をテキストの先頭から探す。  
    テキストの末尾は、0xFFFF  
###  入力文字キャピタライズ指定変数
   「\」: 0のとき、入力文字の大文字/小文字変換を行わない。0以外のとき入力文字の大文字/小文字変換を行う。  

# インタープリタ内部の変更

## プログラム・テキスト表現の変更
  行末は 0x00 に変更。オリジナルは 0x0D (「\r」)  
  テキストの末尾を 0xFFFF の2バイトで表現。オリジナルは記号なし。(インタープリタ内のポインタで、末尾を管理)  
## オーバフローの無視  
  オリジナルは二の補数表現の演算を守り、加算などのオーバフローを検出して、エラーとしていた。  
  本処理系は、オーバフローは関知しない。これは符号なし二進数の計算に適しており、アドレス計算などで便利である。大小比較は二の補数表現として行う。  
   (本処理系の仕様は、GAME言語と同様である)

# オリジナル版の文法
  各ステートメントは、途中で「.」を付けることで後を省略できる。  
  省略形が重複する場合は、インタープリタのキーワード検索順による。ソースコードを参照のこと。  
  NEXTの変数は省略できない。が、「NEXT」は「.」と省略して書ける。つまり「NEXT I」は「.I」と書ける。  
  PRINT文は「,」で改行しない。(Micorsoft BASICでは「;」)  
  PRINT文で「#数,」で、以降の十進出力の桁数を指定する。  
  ちなみに、ダイレクト・モード(プロンプト入力直後)では、「.」が「LIST」の省略形となる。  
  ダイレクト・モードのコマンドは、LIST, NEW, RUN, EDIT のみ。

# RST ジャンプ・テーブル
AKI80版では、RST命令のジャンプ・テーブルを 4Bytes づつ用意してある。初期化はしていない。  
RST1〜7 は RAM上の 0ffe4h〜0fffch へjmpする。このRAM領域にjmp命令を書くなどすれば、任意のルーチンへ飛ばすことができる。  
NMIは、0ffe0hへジャンプする。この領域は、XBASの HotStart へのjmp に初期化してある。  
外部にNMIスイッチを接続し、そのスイッチのOnで、XBASのプロンプトに制御を戻すことができる。そのときプログラム・テキストが消えることがない。  
NMIのジャンプ・テーブルは、ユーザが自由に上書きしてよい。  

; AKI80 version:  
; RST1〜7 jump to 0ffe4h〜0fffch on RAM, Those are not initialized.  
; NMI jumps to 0ffe0h.It's default is "jmp hstrt" as jumps to XBAS's HotStart.    

# ビルド方法
CP/M下で MAC を使用して、ビルドする。  
A> submit xbasaki  
で、ビルド。

CP/M版は、メモリ・アロケーションがめちゃくちゃだが…  
xbaski.asm の先頭の方にある2行を下記に変更し、  
  AKI80 equ 0  
  CPM equ 1  

 A> submit xbasaki  
で、一応ビルド可能。  
CP/Mのメモリによっては実行可能。(私は独自のCP/M,8080シミュレータを使っているので、一応実行している)  
CPMでは、8080命令のみとしているので、IOポートアクセスはできない。  

# 文字入力
1文字入力ルーチンで、英小文字は大文字に、英大文字は小文字に、変換している。   
シリアル端末から、プログラム・コードなどを送り込むときは、変数名などは英小文字にしておかねばならない。(^^;   
変数「\」に 0 をセットすることで、変換を停止できる。 


# ROMやRAMに複数のプログラムを置ける
例えば、trek.bin を、ROMの任意の番地に焼く。  
ここでは、0xBA0番地に trek.bin を焼いたとする。  
xbas が起動後
  \+ [=$BA0  
で、プログラム・テキストの先頭が 0xBA0 となる。  
  \+ ==  
で、プログラム・テキストの末尾が「]」変数にセットされる。
  \+ ??[:??]  
で、それぞれの値が確認できる。  

「[」変数は、どこにでもセットできる。RAM上に、複数のプログラム・テキストを置くことができる。  

# ROMなどに置く、プログラム・テキストのイメージを作る
Linuxで、「xbassrc2bin」を実行する。
  $ xbassrc2bin < trek.xbas > trek.bin  

xbassrc2bin のソースは、xbassrc2bin.c 。Makefileは xbassrc2bin 用。  
 $ make  
で、xbassrc2bin ができる。  
 


